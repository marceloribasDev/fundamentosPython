# -*- coding: utf-8 -*-
"""Exceptions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Os_3-1T8cEcxicwsi3N9IGuzJayLS-W1

# Exceptions

- Ocorrência em que o fluxo do programa produz algum tipo de erro
- Pode ser em decorrência de problemas de codificação ou situação
inesperada (banco de dados indisponível)
- Um exceção não trata causa o fim do programa
- Uma exceção tratada permite controlar o fluxo do programa e se
possível, seguir um caminho diferente

------------------------------------------------------------------------------------------------------------------------

```
try:
    neste bloco pode ocorrer erro
except: [pode haver mais uma cláusula]
    este bloco é executado em caso de erro
else: [opcional]
    executa somente se não houver erro
finally: [opcional]
    sempre será executada, com ou sem err
```
"""

print('Inicio')

lista = [1,2,3]

try:
    print(lista[10])
except Exception as error:
    print('Falha ao acessar linha nao encontrada, erro: ' + str(error))
print('Fim')

print('Inicio')

lista = [1,2,3]

try:
    print(lista[10])
except Exception as error:
    print('Falha ao acessar linha nao encontrada, erro: ' + str(error))
finally:
    del lista
    print('Executa sempre que o try-except acabar, mesmo que nao ocorra erro')
print('Fim')

print('Inicio')

lista = [1,2,3]

try:
    print(lista[0])
except Exception as error:
    print('Falha ao acessar linha nao encontrada, erro: ' + str(error))
else: # Executa somente se nao houver erros
    del lista
    print('Nao houve erro')
print('Fim')

print('Inicio')

lista = [1,2,3]

try: # Codigo que pode dar erro
    print(lista[10]) # Trocar esse valor para teste
except Exception as error: # Codigo executado se der erro
    print('Falha ao acessar linha nao encontrada, erro: ' + str(error))
else: # Codigo executado se nao der erro
    del lista
    print('Nao houve erro')
finally: # Codigo executado sempre
    print('Executa sempre!')
print('Fim')

"""# Tipos de Exceptions"""

print('Aqui inicia')

lista = [1,2,3]

try:
    print(lista[10])
except IndexError as erroIndex: #Erro especifico
    print('Erro de acesso ao index: ' + str(erroIndex))
except:
    print('Ocorreu outro erro')
else:
    print('Executa se nao ocorre erro')

print('Aqui acaba')

from IPython.core.excolors import ExceptionColors
print('Aqui inicia')

lista = [1,2,3]
numero = 0

try:
    divisao = 10 / numero
    print(lista[10])
except IndexError as erroIndex: #Erro especifico
    print('Erro de acesso ao index: ' + str(erroIndex))
except ZeroDivisionError as erroDivisaoZero:
    print('Erro divisao por zero: ' + str(erroDivisaoZero))
except Exception as error:
    print('Ocorreu outro erro' + str(error))
else:
    print('Executa se nao ocorre erro')

print('Aqui acaba')

"""# Gerando as propias exceptions"""

raise Exception('Exception criada')

raise IndexError('Exception de index')

def printa_positivo(numero):
    if numero < 0:
        raise ValueError('Valor nao pode ser negativo')
    print(numero)

try:
    #printa_positivo(-1)
    printa_positivo(10)
    #printa_positivo('b')
except ValueError as erro:
    print('O erro eh: ' + str(erro))    
except Exception as erro1:
    print('Erro qualquer --> ', str(erro1))

def printa_positivo(numero):
    assert(numero >= 0) #Faz o teste logico pra saber se o valor eh maior que zero (nao retorna mensagem)
    print(numero)

try:
    printa_positivo(-1)
    #printa_positivo(10)
    #printa_positivo('b')
except AssertionError as erro:
    print('O erro eh: ' + str(erro))    
except Exception as erro1:
    print('Erro qualquer --> ', str(erro1))

"""# Exercicios"""

'''
1 - Crie uma função que receba duas strings que serão convertidas para 
números para serem somadas, se ao realizar o casting ocorrer um erro, gere 
uma exceção informando o motivo
'''

def soma(str1,str2):
    try:
        num1 = float(str1)
        num2 = float(str2)
        return num1 + num2
    except:
        raise Exception('Falha no casting')

print(soma('1','2')) # sucesso
print(soma('a','2')) # erro

'''
2 - Crie uma função que receba uma lista e um número e retorne o elemento 
da lista na posição deste número. Faça um tratamento para que caso haja um 
acesso fora do índice a função retorne o valor None.
'''

def acessaLista(lista, indice):
    try:
        return lista[indice]
    except:
        return None

lista = [1]

print(acessaLista(lista,0)) # Sucesso
print(acessaLista(lista,2)) # Exception

'''
3 - Crie uma função que leia o input do usuário e retorne o que foi 
digitado, mas caso o input seja interrompido trate a exceção e retorne o 
valor None.
'''

def le_input_seguro():
    try:
        return input('Digite algo: ')
    except:
        return None

print(le_input_seguro())

'''
4 - Crie uma classe que represente um caractere (string de tamanho 1), use 
propriedades ou crie uma função para isso (mas deixe valor privado) e caso 
o usuário tente inserir um texto gere uma exceção dizendo o motivo.
'''

class Caractere:
    def __init__(self, caracter):
        self.__caracter = ''
        self.caracter = caracter

    @property
    def caracter(self):
        return self.__caracter
    
    @caracter.setter
    def caracter(self, value):
        if len(value) > 1:
            raise Exception('Caracter deve ter no maximo tamanho 1')

        self.__caracter = value

letra = Caractere('a')
print(letra.caracter)

try:
    #letra.caracter = 'ab'
    letra.caracter = 'b'
except Exception as ex:
    print(str(ex))

print(letra.caracter)